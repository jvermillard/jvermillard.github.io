<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Embedded software testing with GitHub Actions |
Julien Vermillard</title><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Julien Vermillard"><meta name=description content="
      Julien Vermillard


    "><link rel=stylesheet href=/scss/main.min.5259d55db7b9c675f751f0865411bd84a410f3ffcb5105b8fc00b22fcb739309.css integrity="sha256-UlnVXbe5xnX3UfCGVBG9hKQQ8//LUQW4/ACyL8tzkwk=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css integrity="sha256-bVheeNKMzhIA05+xM8ku2D3wFzjach0PSPturGLSTgQ=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=http://vermillard.com/post/github-actions/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://vermillard.com/images/site-feature-image.png"><meta name=twitter:title content="Embedded software testing with GitHub Actions"><meta name=twitter:description content="Continuous Integration pipelines can greatly improve your embedded software reliability and your release turn-over."><meta property="og:title" content="Embedded software testing with GitHub Actions"><meta property="og:description" content="Continuous Integration pipelines can greatly improve your embedded software reliability and your release turn-over."><meta property="og:type" content="article"><meta property="og:url" content="http://vermillard.com/post/github-actions/"><meta property="og:image" content="http://vermillard.com/images/site-feature-image.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-12-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-16T00:00:00+00:00"><meta property="og:site_name" content="About Me"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Embedded software testing with GitHub Actions","headline":"Embedded software testing with GitHub Actions","alternativeHeadline":"","description":"
      
        Continuous Integration pipelines can greatly improve your embedded software reliability and your release turn-over.


      


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/vermillard.com\/post\/github-actions\/"},"author":{"@type":"Person","name":"Julien Vermillard"},"creator":{"@type":"Person","name":"Julien Vermillard"},"accountablePerson":{"@type":"Person","name":"Julien Vermillard"},"copyrightHolder":{"@type":"Person","name":"Julien Vermillard"},"copyrightYear":"2021","dateCreated":"2021-12-16T00:00:00.00Z","datePublished":"2021-12-16T00:00:00.00Z","dateModified":"2021-12-16T00:00:00.00Z","publisher":{"@type":"Organization","name":"Julien Vermillard","url":"http://vermillard.com/","logo":{"@type":"ImageObject","url":"http:\/\/vermillard.com\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":["http://vermillard.com/images/site-feature-image.png"],"url":"http:\/\/vermillard.com\/post\/github-actions\/","wordCount":"797","genre":[],"keywords":["CI\/CD","Embedded","Github"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile.png alt="profile picture"><h1 class=sidebar__introduction-title><a href=/>About Me</a></h1><div class=sidebar__introduction-description><p>Julien Vermillard</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://linkedin.com/in/jvermillard/ rel=me aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/vrmvrm rel=me aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/jvermillard/ rel=me aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:julien@vermillard.com rel=me aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=/documents/cv.pdf rel=me aria-label=resume title=resume><i class="fas fa-file-pdf fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2021 - 2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LTB2J9BZZP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LTB2J9BZZP")</script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/portfolio/ title>Portfolio</a></li><li class=nav__list-item><a href=/publicspeaking/ title>Public Speaking</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Embedded Software Testing With GitHub Actions</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>16/12/2021</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>4-minute read</span></li></ul><p><img src=/images/gha.png alt="Test Pyramid"></p><p>Continuous Integration pipelines can greatly improve your embedded software reliability and your release turn-over. But it’s a large investment and can be quite time consuming, especially for small teams.</p><p>Assembling and maintaining an “on target” test infrastructure can be hard to stabilize for several reasons.</p><p><img src=/images/test-pyramid.png alt="Test Pyramid"></p><p>My first advice, is to test as much as possible outside the target, unit test and integration testing have even more value than for non-embedded software.</p><p>Avoid on target testing as much as possible! It’s slow and difficult to keep stable over time!</p><p><img src=/images/tddfe.png alt="Test-Driven Development for embedded C"></p><p>I know that usage of unit testing is not that popular in embedded software, but I encourage you to try it! A good starting point is this book: <a href=https://amzn.to/30S1k0W></a></p><p>This will greatly help you to reduce the amount of on target testing you need to do.</p><p>Another way to limit the number of on target test is to use a simulator, there is more and more options every year, for example, <a href=https://twitter.com/kartben>Benjamin Cabé</a> made me discover <a href=https://renode.io/>Renode</a> which is quite useful for micro-controller targets</p><p>That said, you still need to run a handful of tests on your targeted device. At minimum, a couple of acceptance tests. And running this kind of test is looong because you need to reboot, flash, reboot, wait the system to be up, test, maybe retry because your network is flaky.</p><p>Furthermore, if you want to hook your test suite on your pull-request, you will need a pool of test bench to be able to parallelize the tests.</p><p>So, flaky test, multiplying test benches and having a master to control it can be, at minimum, a distraction up to a annoying daily burden for a software team. And in my experience, embedded software engineers are rarely comfortable with server infra technologies like Docker or K8S, server installation and monitoring. That’s why I started to look at moving from in-house maintained server/runner with managed solutions like GitHub Actions.</p><p>GitHub Actions let you run “action runners” on your own hardware in your own network. The runner communicate back with GitHub cloud servers using HTTP long polling, which minimize the number of holes you need to punch into your corporate network.</p><p>Action Runner are open source and are really easy to install on a Linux box, even on a Raspberry Pi: Go to the Actions setting in your repository and click the button to add a new Self Hosted Runner, just follow the instruction: download the package for the right architecture (X64/ARM/ARM64), decompress the archive and setup the systemd service using the provided ./svc.sh install script.</p><p>Remember to create a dedicated user and add it to the right groups to manipulate the needed I/O (for example, you will need the “dialout” group to access any serial port).</p><p>And that’s it! Your runner will appear on the GitHub action console!</p><p>For redirecting any job of your GitHub workflow to the host runner you need to specify it the .yml:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>runs-on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>— self-hosted</span><span class=w>
</span></span></span></code></pre></div><p>You can add more label to be able to target a specific runner connected to a specific variation of your hardware.</p><p>Now you have a working test bench, there is still something to tweak to stabilize your setup: in my experience, embedded system doesn’t like to be flashed multiple times per day, especially if you hook your CI on pull request commits.</p><p>After a couple of flashing my devices are randomly stuck, sometime due to some weird USB driver error, sometimes due to the previous test campaign which put the device in an unexpected state.</p><p>Anyway, it’s not a really common use case for most of the hardware platform to be flashed a dozen of time without a power cycle and it’s often complicated to correct it.</p><p>The workaround is quite simple: reboot and flash your device to a well know configuration before each test run. There are multiple ways to do this:</p><ul><li><p>a programmable power supply to shutdown your target before every test campaign, which can be costly and bulky but work (example: <a href=https://amzn.to/3jAjevM>https://amzn.to/3jAjevM</a>) use a USB driven relay to connected to your power supply (example:<a href=https://amzn.to/3GkzKd1></a>)
<img src=/images/relay.png alt="Reset using a relay"></p></li><li><p>same trick but different: connect the reset signal to the relay and reset your device
*if your device is powered over USB, maybe you don’t need any extra hardware! a lot of USB hub or USB controller power are software controllable: <a href=https://github.com/mvp/uhubctl></a>,</p></li></ul><p>Adopting GitHub action and private runners was really a breath. They are still quite new for me and I don’t have a lot of feedback at the moment, but until now the experience was pleasant and not having to deal with heavy weight and complicated CI servers was a relief.</p><p>I would be curious to hear about your experience, and your pain points when working with Continuous Integration and Embedded software testing. Let me know in the comments below!</p></div><div class=post__footer><span><a class=tag href=/tags/ci/cd/>CI/CD</a><a class=tag href=/tags/embedded/>Embedded</a><a class=tag href=/tags/github/>Github</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2021 - 2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LTB2J9BZZP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LTB2J9BZZP")</script></body></html>